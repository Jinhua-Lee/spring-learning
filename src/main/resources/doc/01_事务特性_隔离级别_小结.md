# 01_事务特性\_隔离级别\_小结

## 一、事务四大特性

### 1. 原子性（Atomicity）

* 整个事务中的所有操作，要么**全部成功提交**，要么**全部失败回滚**。
* **不可以仅执行一部分**，即为原子性。

### 2. 一致性（Consistency）

* 数据库**总是**从一个一致性状态**转换到另一个**一致性状态。
* 即使**系统中途崩溃**，所做的操作最终未提交，所做的修改不会保存到数据库，还是之前的状态。

### 3. 隔离性（Isolation）

* 除了隔离级别为**读未提交（Read uncommitted）**的场景，一个事务所做的修改，在提交前，其他事务是不可见的。

### 4. 持久性（Durability）

* 一旦事务提交，所做的修改回**永久保存**到数据库中。
* 即使系统崩溃，修改的数据也不会丢失。重启时必须保证通过某种机制**恢复数据**。

## 二、事务隔离级别

### 1. 隔离级别的伴生问题

#### 1) 脏读（Dirty Read）

* 读取到另一个事务**未提交（Uncommitted）**的数据。

* 举例：

  1. 事务1【tx_1】：张三给李四转100元。

  2. 事务2【tx_2】：李四查询自己的账户。

     | 时刻   | 事务 | 事务状态                          |
     | ------ | ---- | --------------------------------- |
     | **t1** | tx_1 | 开始事务tx_1；                    |
     | **t2** | tx_1 | 张三给李四转账100元；             |
     | **t3** | tx_2 | 开始事务tx_2；                    |
     | **t4** | tx_2 | 李四查看自己账户，**多了100元**； |
     | **t5** | tx_2 | 提交事务tx_2。                    |
     | **t6** | tx_1 | **回滚**事务tx_1。                |

#### 2) 不可重复读（Unrepeatable Read）

* **同一事务中**，对同一记录的**两次读取不一致**，因为**另一事务对该记录做了修改（Update）**。

  1. 事务1【tx_1】：酒店两次查看1024房间状态；

  2. 事务2【tx_2】：预定1024号房间。

     | 时刻   | 事务 | 事务状态                     |
     | ------ | ---- | ---------------------------- |
     | **t1** | tx_1 | 开始事务tx_1；               |
     | **t2** | tx_1 | 查看1024房间，**空闲**；     |
     | **t3** | tx_2 | 开始事务tx_2；               |
     | **t4** | tx_2 | **预订**1024号房间；         |
     | **t5** | tx_2 | **提交**事务tx_2。           |
     | **t6** | tx_1 | 再次查看1024房间，**使用**； |
     | **t7** | tx_1 | 提交事务tx_1。               |

#### 3) 幻读（Phantom Read）

* 对同一张表的两次查询**数目不一致**，另一个事务**插入（Insert）**了记录。

### 2. 四大事务隔离级别

| 隔离级别     | 枚举值 | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ------------ | ------ | ---- | ---------- | ---- | ------ |
| **读未提交** | 1      | yes  | yes        | yes  | no     |
| **读已提交** | 2      | no   | yes        | yes  | no     |
| **可重复读** | 4      | no   | no         | yes  | no     |
| **串行化**   | 8      | no   | no         | no   | yes    |

#### 1) 读未提交（Read Uncommitted）

* 事务中的修改，**即使未提交**，**对其他事务也是可见的**。
* 带来脏读，导致很多问题。
* 性能上不会好太多。

#### 2) 读已提交（Read Committed）

* 对任意事务，只能看到**已提交**的修改。
* **大多数**数据库系统（如Oracle）的默认隔离级别。
* 解决脏读问题，为解决不可重复读问题。

#### 3) 可重复读（Reapeatable Read）

* 保证了在同一事务中，多次读取同样记录的一致性。
* 无法解决幻读的问题。
* MySQL中的默认隔离级别。通过InnoDB和XtraDB的多版本并发控制，解决幻读问题。

#### 4) 串行化（Serializable）

* 最高隔离级别。强制事务串行执行。
* 对每一行读取都加加锁，可导致大量的超时和锁争用问题。
* 实际应用很少，可以接受没有并发的情况下使用。

